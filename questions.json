{
  "categories": {
    "oop": {
      "title": "Object Oriented Programming",
      "questions": [
        {
          "id": 1,
          "question": "Method overriding (geçersiz kılma) ne anlama gelir?",
          "options": [
            "Generic metodların specific type'larla specialization'ı",
            "Inheritance hierarchy'sinde parent metodun child class'ta yeniden tanımlanması",
            "Abstract class'taki metodların interface'e taşınması",
            "Compile time'da method resolution'ının belirlenmesi"
          ],
          "correctAnswer": 1,
          "explanation": "Method overriding, parent class'taki metodun child class'ta yeniden tanımlanmasıdır"
        },
        {
          "id": 2,
          "question": "\"Composition over inheritance\" prensibi ne anlama gelir?",
          "options": [
            "Static method'ların instance method'lardan daha verimli olması",
            "Multiple inheritance'ın single inheritance'tan üstün olması",
            "Object'leri birleştirerek functionality kazanmanın inheritance'tan daha esnek olması",
            "Abstract class'ların interface'lerden daha kullanışlı olması"
          ],
          "correctAnswer": 2,
          "explanation": "Composition, inheritance'a göre daha esnek ve gevşek bağlı tasarım sağlar"
        },
        {
          "id": 3,
          "question": "Çok biçimlilik (polymorphism) kavramı neyi ifade eder?",
          "options": [
            "Generic types kullanarak type-safe collections oluşturulması",
            "Bir object'in runtime'da type casting ile farklı türlere dönüştürülmesi",
            "Bir class'ın multiple inheritance özelliği göstermesi",
            "Aynı interface'i implement eden farklı class'ların farklı davranışlar sergilemesi"
          ],
          "correctAnswer": 3,
          "explanation": "Polymorphism, aynı interface'i farklı şekillerde implement etme yeteneğidir"
        },
        {
          "id": 4,
          "question": "Bu C# kodunun çıktısı ne olur?\\n\\nclass Animal {\\n    public virtual void MakeSound() {\\n        Console.WriteLine(\\\"Animal makes a sound\\\");\\n    }\\n}\\n\\nclass Dog : Animal {\\n    public override void MakeSound() {\\n        Console.WriteLine(\\\"Dog barks\\\");\\n    }\\n}\\n\\nstatic void Main() {\\n    Animal myAnimal = new Dog();\\n    myAnimal.MakeSound();\\n}",
          "options": [
            "İki satır da yazdırır",
            "\"Dog barks\"",
            "Compile error verir",
            "\"Animal makes a sound\""
          ],
          "correctAnswer": 1,
          "explanation": "Polymorphism sayesinde runtime'da Dog sınıfının MakeSound metodu çağrılır"
        },
        {
          "id": 5,
          "question": "Nesne yönelimli programlamanın 4 temel prensibi hangisidir?",
          "options": [
            "Coupling, Cohesion, Separation, Integration",
            "Composition, Aggregation, Association, Dependency",
            "Inheritance, Polymorphism, Encapsulation, Abstraction",
            "Modularity, Reusability, Maintainability, Scalability"
          ],
          "correctAnswer": 2,
          "explanation": "OOP'nin 4 temel prensibi: Kalıtım, Çok biçimlilik, Kapsülleme ve Soyutlama"
        },
        {
          "id": 6,
          "question": "Design pattern'ler yazılım geliştirmede neden kullanılır?",
          "options": [
            "Memory usage'ı azaltma",
            "Yaygın problemlere kanıtlanmış çözümler sunarak code quality'yi artırma",
            "Compile time'ı kısaltma",
            "Execution performance'ı optimize etme"
          ],
          "correctAnswer": 1,
          "explanation": "Design pattern'ler yaygın problemlere test edilmiş çözümler sunar"
        },
        {
          "id": 7,
          "question": "Getter ve setter metodları hangi amaca hizmet eder?",
          "options": [
            "Reflection API kullanarak runtime'da field access'i optimize eder",
            "Thread-safe operations için synchronization mekanizması sunar",
            "Private field'lara controlled access sağlayarak encapsulation'ı korur",
            "Object serialization ve deserialization işlemlerini yönetir"
          ],
          "correctAnswer": 2,
          "explanation": "Getter/setter metodları encapsulation prensibini koruyarak kontrollü erişim sağlar"
        },
        {
          "id": 8,
          "question": "Abstraction ile Encapsulation arasındaki temel fark nedir?",
          "options": [
            "Abstraction interface kullanır, Encapsulation class kullanır",
            "İkisi arasında fark yoktur",
            "Abstraction daha hızlıdır, Encapsulation daha güvenlidir",
            "Abstraction complexity'yi gizler, Encapsulation implementation'ı gizler"
          ],
          "correctAnswer": 3,
          "explanation": "Abstraction karmaşıklığı gizler, Encapsulation implementasyon detaylarını gizler"
        },
        {
          "id": 9,
          "question": "Constructor (yapıcı metod) için hangisi doğrudur?",
          "options": [
            "Static members'ı initialize etmek için kullanılır",
            "Object'in lifecycle'ı boyunca memory allocation'ını yönetir",
            "Inheritance hierarchy'sinde parent class'ları bağlar",
            "Object instantiation sırasında otomatik çağrılır ve initial state'i ayarlar"
          ],
          "correctAnswer": 3,
          "explanation": "Constructor, nesne oluşturulurken otomatik çağrılan ve başlangıç durumunu ayarlayan metoddur"
        },
        {
          "id": 10,
          "question": "Partial class'ların kullanım amacı nedir?\\n\\npublic partial class Employee {\\n    // Part 1\\n}\\npublic partial class Employee {\\n    // Part 2\\n}",
          "options": [
            "Memory usage optimize etmek",
            "Performance optimization",
            "Multiple inheritance simüle etmek",
            "Büyük class'ları birden fazla dosyaya bölerek maintainability sağlamak"
          ],
          "correctAnswer": 3,
          "explanation": "Partial class'lar büyük sınıfları birden fazla dosyaya bölerek yönetimi kolaylaştırır"
        },
        {
          "id": 11,
          "question": "Method overloading (aşırı yükleme) hangi durumu tanımlar?",
          "options": [
            "Interface'teki abstract metodların concrete class'ta tanımlanması",
            "Static metodların runtime'da dynamic olarak çağrılması",
            "Aynı class içinde aynı isimde farklı parameter signature'lı metodlar",
            "Parent class'taki bir metodun child class'ta yeniden implement edilmesi"
          ],
          "correctAnswer": 2,
          "explanation": "Method overloading, aynı isimde farklı parametreli metodlar tanımlamaktır"
        },
        {
          "id": 12,
          "question": "Class ve Object arasındaki ilişki için hangisi doğrudur?",
          "options": [
            "Object static yapıdır, Class dynamic olarak değişebilir",
            "Class bir şablondur, Object bu şablondan üretilen örnektir",
            "Class runtime'da oluşur, Object compile time'da tanımlanır",
            "Object bir blueprint'tir, Class bu blueprint'ten türetilen instance'dır"
          ],
          "correctAnswer": 1,
          "explanation": "Class bir şablon/blueprint'tir, Object ise bu şablondan oluşturulan instance'dır"
        },
        {
          "id": 13,
          "question": "Nesne Yönelimli Programlama yazılım geliştirmede neden yaygın tercih edilir?",
          "options": [
            "Database işlemlerinde SQL sorgularını optimize eder",
            "Functional programming paradigmasından daha hızlı execution time sunar",
            "Kodun modülerliğini artırarak yeniden kullanılabilirliğini ve bakımını kolaylaştırır",
            "Memory management'ı otomatik hale getirerek garbage collection sağlar"
          ],
          "correctAnswer": 2,
          "explanation": "OOP'nin ana avantajı kod modülerliği, yeniden kullanılabilirlik ve bakım kolaylığıdır"
        },
        {
          "id": 14,
          "question": "Aşağıdakilerden hangisi Phone sınıfından bir nesne oluşturmak için doğru bir C# ifadesidir?\\n\\nclass Phone {\\n    public string Brand;\\n}",
          "options": [
            "Phone = new Phone();",
            "Phone myPhone = Phone();",
            "Phone myPhone = new Phone();",
            "myPhone = new Phone();"
          ],
          "correctAnswer": 2,
          "explanation": "C#'ta nesne oluşturmak için 'Type variableName = new Type();' syntax'ı kullanılır"
        },
        {
          "id": 15,
          "question": "Nesne Yönelimli Programlama'nın en önemli avantajı nedir?",
          "options": [
            "Cross-platform compatibility için automatic code generation yapar",
            "Code reusability ve maintainability sağlayarak development efficiency'yi artırır",
            "Compiler optimization'ları sayesinde faster execution time sunar",
            "Procedural programming'e göre daha az memory consumption gösterir"
          ],
          "correctAnswer": 1,
          "explanation": "OOP'nin en önemli avantajı kod yeniden kullanılabilirliği ve bakım kolaylığıdır"
        }
      ]
    },
    "sql": {
      "title": "SQL Database",
      "questions": [
        {
          "id": 1,
          "question": "SQL'de Cross Join (Kartezyen Çarpım) ne yapar?",
          "options": [
            "Hiçbir kayıt getirmez",
            "Sadece NULL olmayan kayıtları getirir",
            "İlk tablonun her satırını ikinci tablonun her satırıyla eşleştirir",
            "Sadece eşleşen kayıtları getirir"
          ],
          "correctAnswer": 2,
          "explanation": "Cross Join kartezyen çarpım yaparak tüm kombinasyonları oluşturur"
        },
        {
          "id": 2,
          "question": "Aşağıdaki SQL komutlarından hangisi DDL (Data Definition Language) kategorisine aittir?",
          "options": [
            "UPDATE",
            "CREATE",
            "INSERT",
            "SELECT"
          ],
          "correctAnswer": 1,
          "explanation": "CREATE komutu DDL kategorisinde olup veritabanı yapısını tanımlar"
        },
        {
          "id": 3,
          "question": "SQL'de LAG() ve LEAD() fonksiyonlarının diğer SQL fonksiyonlarından ayıran en temel özelliği nedir?",
          "options": [
            "Koşullu ifadelerle filtreleme yapmaya olanak tanır",
            "Bir satırın önceki veya sonraki satırdaki değerine erişim sağlar",
            "Gruplanmış veriler üzerinde gruplama işlemleri gerçekleştirir",
            "Verileri belirli bir kritere göre sıralamak için kullanılır"
          ],
          "correctAnswer": 1,
          "explanation": "LAG() ve LEAD() window fonksiyonları önceki/sonraki satırlara erişim sağlar"
        },
        {
          "id": 4,
          "question": "Aşağıdaki DCL komutlarından hangisi kullanıcının DELETE iznini kalıcı olarak kaldırır?",
          "options": [
            "DELETE ACCESS TO Kullanici",
            "GRANT DELETE TO Kullanici",
            "DENY DELETE TO Kullanici",
            "REVOKE DELETE FROM Kullanici"
          ],
          "correctAnswer": 3,
          "explanation": "REVOKE komutu verilen izinleri geri alır"
        },
        {
          "id": 5,
          "question": "Hangi veri tipi tarih ve saat bilgisi saklamak için kullanılır ve en yüksek hassasiyete sahiptir?",
          "options": [
            "TIME",
            "DATETIME2",
            "DATE",
            "DATETIME"
          ],
          "correctAnswer": 1,
          "explanation": "DATETIME2 en yüksek hassasiyetli tarih-saat veri tipidir"
        },
        {
          "id": 6,
          "question": "SQL'de Self Join ne demektir?",
          "options": [
            "Primary key ile foreign key birleştirme",
            "Aynı tablonun kendisiyle birleştirilmesi",
            "İki farklı veritabanından tablo birleştirme",
            "Sadece sayısal sütunların birleştirilmesi"
          ],
          "correctAnswer": 1,
          "explanation": "Self Join aynı tablonun kendisiyle birleştirilmesidir"
        },
        {
          "id": 7,
          "question": "Bir veritabanı sisteminin ACID özelliklerinden İzolasyon neyi ifade eder?",
          "options": [
            "Bir işlemin sonuçlarının kalıcı olmasını ve sistem çökse bile kaybolmamasını sağlar",
            "Bir işlemin tamamlandığında verilerin tutarlı ve geçerli durumda olmasını garanti eder",
            "Birden fazla eşzamanlı işlemin birbirini izole ederek tutarsızlık yaratmasını önler",
            "Bir işlemin tüm adımlarının ya tamamının başarılı ya da tamamının başarısız olmasını sağlar"
          ],
          "correctAnswer": 2,
          "explanation": "İzolasyon, eşzamanlı işlemlerin birbirini etkilemesini önler"
        },
        {
          "id": 8,
          "question": "Aşağıdaki SQL veri tiplerinden hangisi ondalıklı sayılar için kullanılır ve en yüksek hassasiyeti sunar?",
          "options": [
            "REAL",
            "DECIMAL(10,2)",
            "FLOAT(53)",
            "MONEY"
          ],
          "correctAnswer": 2,
          "explanation": "FLOAT(53) en yüksek hassasiyetli ondalıklı sayı veri tipidir"
        },
        {
          "id": 9,
          "question": "SQL'de normalizasyon hakkında hangisi DOĞRUdur?",
          "options": [
            "Performansı her zaman düşürür",
            "Veri tutarlılığını sağlamak ve tekrarı önlemek için yapılır",
            "Veri tekrarını artırmak için yapılır",
            "Sadece büyük tablolarda uygulanır"
          ],
          "correctAnswer": 1,
          "explanation": "Normalizasyon veri tutarlılığını sağlar ve tekrarı önler"
        },
        {
          "id": 10,
          "question": "Bir marketin Urunler (urun_id, stok, fiyat) tablosu var. Bazı ürünlerin stok bilgisi NULL. Yönetici, stok bilgisi girilmiş olan ürünlerin ortalama fiyatını hesaplamak istiyor.\\nİstenen sonucu veren sorgu hangisidir?",
          "options": [
            "SELECT AVG(fiyat) FROM Urunler WHERE stok = NOT NULL;",
            "SELECT AVG(fiyat) FROM Urunler WHERE stok <> NULL;",
            "SELECT AVG(fiyat) FROM Urunler WHERE stok IS NOT NULL;",
            "SELECT AVG(fiyat) FROM Urunler HAVING stok IS NOT NULL;"
          ],
          "correctAnswer": 2,
          "explanation": "NULL kontrolü için IS NOT NULL operatörü kullanılmalıdır"
        },
        {
          "id": 11,
          "question": "Veritabanında Deadlock ne demektir?",
          "options": [
            "Disk alanının dolması",
            "İki veya daha fazla işlemin birbirini beklemesi sonucu oluşan kilitlenme",
            "Çok fazla kullanıcının aynı anda bağlanması",
            "Veritabanının tamamen durması"
          ],
          "correctAnswer": 1,
          "explanation": "Deadlock, işlemlerin birbirini beklemesi sonucu oluşan kilitlenmedir"
        },
        {
          "id": 12,
          "question": "Data Warehouse'un temel amacı ve özelliği aşağıdakilerden hangisidir?",
          "options": [
            "Sadece yapısal (SQL) verileri işler ve ham verileri değiştirmeden olduğu gibi saklar",
            "Farklı kaynaklardan gelen verileri tarihsel analiz için entegre eder, karar destek sistemlerinde kullanılmak üzere hazırlar",
            "Anlık işlem (OLTP) sistemleri gibi gerçek zamanlı veri depolar ve güncel veri sorguları için optimize edilmiştir",
            "Verileri fiziksel olarak tek bir sunucuda depolar ve depolama kapasitesini en üst düzeye çıkarmak için tasarlanmıştır"
          ],
          "correctAnswer": 1,
          "explanation": "Data Warehouse farklı kaynaklardan gelen verileri analiz için entegre eder"
        },
        {
          "id": 13,
          "question": "Aşağıdaki DCL komutlarından hangisi kullanıcıya sadece SELECT izni verir?",
          "options": [
            "REVOKE SELECT FROM Kullanici",
            "GRANT Kullanici TO SELECT",
            "GRANT SELECT TO Kullanici",
            "GRANT ALL ON Tablo TO Kullanici"
          ],
          "correctAnswer": 2,
          "explanation": "GRANT SELECT TO komutu kullanıcıya sadece okuma izni verir"
        },
        {
          "id": 14,
          "question": "SQL'de NULL değer hakkında hangisi YANLIŞtır?",
          "options": [
            "NULL kullanılan matematiksel işlemlemlerde sonuç NULL döner",
            "NULL = NULL karşılaştırması FALSE döner",
            "IS NULL operatörü ile kontrol edilir",
            "NULL bir değer yokluğunu ifade eder"
          ],
          "correctAnswer": 1,
          "explanation": "NULL = NULL karşılaştırması UNKNOWN döner, FALSE değil"
        },
        {
          "id": 15,
          "question": "Bir restoranın Yemekler (yemek_id, isim, fiyat) ve SiparisDetaylari (siparis_id, yemek_id, adet) tabloları var. Bazı yemekler hiç sipariş edilmemiş. Şef, en az 10 kez sipariş edilen yemeklerin ortalama fiyatını öğrenmek istiyor.\\n\\nİstenen bilgiyi doğru şekilde veren sorgu hangisidir?",
          "options": [
            "SELECT y.fiyat FROM Yemekler y JOIN SiparisDetaylari s ON y.yemek_id = s.yemek_id GROUP BY y.yemek_id, y.fiyat HAVING SUM(s.adet) >= 10;",
            "SELECT AVG(fiyat) FROM (SELECT y.fiyat FROM Yemekler y JOIN SiparisDetaylari s ON y.yemek_id = s.yemek_id GROUP BY y.yemek_id, y.fiyat HAVING SUM(s.adet) >= 10) t;",
            "SELECT AVG(y.fiyat) FROM Yemekler y WHERE y.yemek_id IN (SELECT s.yemek_id FROM SiparisDetaylari s GROUP BY s.yemek_id HAVING SUM(s.adet) >= 10);",
            "SELECT AVG(fiyat) FROM Yemekler y JOIN SiparisDetaylari s ON y.yemek_id = s.yemek_id GROUP BY y.yemek_id HAVING SUM(s.adet) >= 10;"
          ],
          "correctAnswer": 1,
          "explanation": "Subquery ile önce filtreleme yapıp sonra ortalama almak doğru yaklaşımdır"
        }
      ]
    }
  }
}